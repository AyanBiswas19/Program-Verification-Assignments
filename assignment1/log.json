{"1584033457.9977908": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584033487.5980196": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584110922.3679364": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584111170.8840873": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  assert x == product(M, N, P, Q, a, b);\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584111208.0286083": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b);\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  assert x == product(M, N, P, Q, a, b);\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584111239.8702064": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  assert x == product(M, N, P, Q, a, b);\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584111321.2615469": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  y=product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584111338.297351": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584112280.5416653": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = 0;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113051.7313297": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = 0;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113221.1947656": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] {|*|+|-|/|} b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113273.8492024": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] {(|*|+|-|/|)} b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113285.905584": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] {(*|+|-|/)} b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113338.9512837": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] {|(*|+|-|/)|} b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113377.4375541": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += {| a[i, k] (*|+|-|/) b[k, j] |};\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113401.8461726": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += {| (a[i, k]) (*|+|-|/) (b[k, j]) |};\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113448.9159892": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += {| (a[i, k]) (*|+) (b[k, j]) |};\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113515.554773": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        //sum += a[i, k] * b[k, j];\n        sum += a[i, k] ?? b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113536.3373058": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        //sum += a[i, k] * b[k, j];\n        sum += ??;\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113580.213498": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = ??;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113615.4573288": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113620.2276423": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = ??;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113720.6370308": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i=0; i < M; i++){\n    for(int j=0; j < Q; j++){\n      sum = ??;\n      for(int k=0; k < P; k++){\n        //sum += a[i, k] * b[k, j];\n        {|sum (+=|-=) (a[i, k] * b[k, j])|}\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113759.537323": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < M; i++){\n    for(int j=??; j < Q; j++){\n      sum = ??;\n      for(int k=??; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113830.9232788": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < ??; i++){\n    for(int j=??; j < Q; j++){\n      sum = ??;\n      for(int k=??; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113835.8968496": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < ??; i++){\n    for(int j=??; j < Q; j++){\n      sum = ??;\n      for(int k=??; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584113888.9105675": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < M; i++){\n    for(int j=??; j < Q; j++){\n      sum = ??;\n      for(int k=??; k < P; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584115241.0564766": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < {|(M|Q|P)|}; i++){\n    for(int j=??; j < {|(M|Q|P)|}; j++){\n      sum = ??;\n      for(int k=??; k < {|(M|Q|P)|}; k++){\n        sum += a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584115364.2479048": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < {|(M|Q|P)|}; i++){\n    for(int j=??; j < {|(M|Q|P)|}; j++){\n      sum = ??;\n      for(int k=??; k < {|(M|Q|P)|}; k++){\n        //sum += a[i, k] * b[k, j];\n        sum  {|(+=|-=|=)|} a[i, k] * b[k, j];\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584115387.509878": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < {|(M|Q|P)|}; i++){\n    for(int j=??; j < {|(M|Q|P)|}; j++){\n      sum = ??;\n      for(int k=??; k < {|(M|Q|P)|}; k++){\n        //sum += a[i, k] * b[k, j];\n        sum  {|(+=|-=|=)|} (a[i, k] * b[k, j]);\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584115679.7394824": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != nullptr)\n    ptr=ptr.next;\n  ptr.next= new Node;\n  ptr.next= n;\n  ptr.next.next= nullptr;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != nullptr){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node;\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val = 70;\n}\n"}, "1584115776.7306256": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  for(int i= ??; i < {|(M|Q|P)|}; i++){\n    for(int j=??; j < {|(M|Q|P)|}; j++){\n      sum = ??;\n      for(int k=??; k < {|(M|Q|P)|}; k++){\n        sum += a[i, k] * b[k, j];\n        //sum  {|(+=|-=|=)|} (a[i, k] * b[k, j]);\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n}\n"}, "1584116064.7523654": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != nullptr)\n    ptr=ptr.next;\n  (ptr.next) = new Node;\n  ptr.next = n;\n  ptr.next.next= nullptr;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != nullptr){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node;\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val = 70;\n}\n"}, "1584116073.8128524": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != nullptr)\n    ptr=ptr.next;\n  ptr.next = new Node;\n  ptr.next= n;\n  ptr.next.next= nullptr;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != nullptr){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node;\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val = 70;\n}\n"}, "1584116532.3895779": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != nullptr)\n    ptr=ptr.next;\n  ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= nullptr;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != nullptr){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node;\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val = 70;\n}\n"}, "1584116542.4693935": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != nullptr)\n    ptr=ptr.next;\n  ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= nullptr;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != nullptr){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val = 70;\n}\n"}, "1584116557.3460643": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != nullptr)\n    ptr=ptr.next;\n  ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= nullptr;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != nullptr){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584116590.939151": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i < pos - 1)\n    return lst;\n  n.next=ptr.next;\n  ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584117323.0530312": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584117410.774766": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < pos && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584117459.4672806": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n}\n"}, "1584117942.6779776": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n}\n"}, "1584118048.9098146": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  if(i == 0){\n    lst.head = n;\n    return lst;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118131.0988448": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118135.6973267": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118370.5235288": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118508.7273316": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == null){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118532.078517": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == null){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  //l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118552.0239315": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == null){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  //l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118556.960626": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == null){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != null)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118771.0771718": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= ??;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118798.9169254": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118813.0176272": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= ??;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584118849.2323315": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119085.756993": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= ??;\n  assert ptr.next.val = n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119114.9314666": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next = ??;\n  assert ptr.next.val = n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119123.7218704": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  (ptr.next) = ??;\n  assert ptr.next.val = n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119132.944527": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next = n;\n  assert ptr.next.val = n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119170.9180617": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= ??;\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119194.1515536": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= ??;\n // assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119219.1923614": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= ??;\n  assert ptr.next == n;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119242.3082297": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= n;\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119287.1604521": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119406.3890631": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr=ptr.next;\n  //ptr.next = new Node();\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119667.7770195": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119678.0913022": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  while(ptr.next != ??)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119790.6237264": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n"}, "1584119988.1173077": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  list l = new list();\n  l=l.append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=l.append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120001.6016114": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  list l = new list(head = null);\n  l=l.append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=l.append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120020.6819382": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new list(head = null);\n  l=l.append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=l.append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120053.9077497": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=l.append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=l.append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120056.9060266": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=l.append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=l.append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120081.1433508": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val l= 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120103.2464778": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert.l.head.next.next==null; \n}"}, "1584120120.5047605": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120207.6525998": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return ??;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120248.4886682": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == 0){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120280.268606": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=0;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120316.531576": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  while(i < (pos -1) && ptr != null){\n    ptr=ptr.next;\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120376.8534417": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  while(i < (pos -1) && ptr != null){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  n.next=ptr.next;\n  //ptr.next=new Node();\n  ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120480.8610985": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != null){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  n.next=??;\n  ptr.next=??;\n  assert n.next=ptr.next.next;\n  assert ptr.next=n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120498.074968": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != null){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  n.next=??;\n  ptr.next=??;\n  assert n.next ==ptr.next.next;\n  assert ptr.next ==n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120531.770699": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != null){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  n.next=??;\n  assert n.next == ptr.next;\n  ptr.next=??;\n  assert ptr.next ==n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120558.2699938": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != null){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  n.next={|(ptr.next|ptr|lst.head)|};\n  assert n.next == ptr.next;\n  ptr.next={|(ptr.next|ptr|lst.head)|};\n  assert ptr.next == n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120570.145706": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  //ptr.next = new Node();\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n  // your code here\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != null){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  n.next={|(ptr.next|ptr|lst.head)|};\n  assert n.next == ptr.next;\n  ptr.next={|(ptr.next|ptr|lst.head| n)|};\n  assert ptr.next == n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120703.25129": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != ??){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  // it's VERY difficult to understand how I link pointers. I'll just regex generator them and let sketch figure out\n  n.next={|(ptr.next|ptr|lst.head)|};\n  assert n.next == ptr.next;\n  ptr.next={|(ptr.next|ptr|lst.head| n)|};\n  assert ptr.next == n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}, "1584120847.8348148": {"problem_number": 1, "source_code": "/*\nProblem Number: 1\n=================\n\nTask: Implement the productSK(M, N, P, Q, a, b) function.  This\nfunctions returns cross product of given matricies 'a' and 'b', just\nas the function product(M, N, P, Q, a, b).\n\nThis function should be a partial implementation - meaning that you\nneed to use generators to implement this function.\n\nTo test your function, run the following command in your shell.\n\n-------------------------------------------------\n$ python3 run.py 1 product.sk                  \n-------------------------------------------------\n\nIf the compilation succeeds, you can see the resulting C++ code in the\nfile 'product.cpp'.\n*/\n\nint[M, Q] productSK(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n  // your code here\n  assert P == N;\n  int[M, Q] x;\n  int sum = ??;\n  // In matrix multiplication, I genuinely get confused about the order of loops.\n  // This is a place where sktech generators actually come in use rather than just for demonstrating\n  // Using generators to select the limits of i ,j, and k.\n  for(int i= ??; i < {|(M|Q|P)|}; i++){\n    for(int j=??; j < {|(M|Q|P)|}; j++){\n      sum = ??;\n      for(int k=??; k < {|(M|Q|P)|}; k++){\n        sum += a[i, k] * b[k, j];\n        //sum  {|(+=|-=|=)|} (a[i, k] * b[k, j]);\n      }\n      x[i , j] = sum;\n    }\n  }\n  int[M, Q] y = product(M, N, P, Q, a, b);\n  for(int i= 0; i < M; i++)\n    for(int j= 0; j < N; j++)\n  assert x[i,j] == y[i ,j];\n  return x;\n}\n\n\n\n/* The product(M, N, P, Q, a, b) function performs cross product of\n   the matricies 'a' and 'b' and returns a matrix of dimensions M x Q.\n   This is a complete implementation in sketch, which does not use any\n   generators.\n*/\nint[M, Q] product(int M, int N, int P, int Q, int[M, N] a, int[P, Q] b) {\n       assert P == N;\n       int sum = 0;\n       int[M][N] prod;\n       for (int i = 0; i < M; i++) {\n       \t   for (int j = 0; j < Q; j++) {\n\t       sum = 0;\n\t       for (int k = 0; k < P; k++) {\n\t\t   sum += a[i, k] * b[k, j];\n\t\t   }\n\t       prod[i][j] = sum;\n\t   }\n       }\n       return prod;\n}\n\n\n\nharness void multTest(){\n\tassert product(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n\tassert productSK(3, 2, 2, 3, {{1,2}, {1, 5}, {3, 4}}, {{1,2,3}, {0, 2, 1}}) == {{1, 6, 5}, {1, 12, 8}, {3, 14, 13}};\n  //adding test cases from geeksforgeeks.com\n}\n"}, "1584120861.5346985": {"problem_number": 2, "source_code": "/*\nProblem Number: 2\n=================\n\nTask 1 : Implement the append(List lst, Node n) function which takes a\nlinked list, and a Node and appends the given node to the linked list.\n\nTask 2 : Implement the insertAt(List lst, int pos) function which\ntakes a linked list, a node and the position where the node should be\ninserted in the list, and returns the list with the node inserted at\nthat position.\n*/\nstruct Node{\n       Node next;\n       int val;\n}\n\nstruct List{\n       Node head;\n}\n\nList append(List lst, Node n) {\n  if( lst.head == ??){\n    lst.head=n;\n    return lst;\n  }\n  Node ptr = lst.head;\n  //Using a generator. I don't want to figure out the measure function. generator two lines upp will help.\n  while(ptr.next != null)\n    ptr= {|(ptr.next|ptr|lst.head)|};\n  // playing the role of a lazy programmer. why would I want to think what to assign? I have three pointers, has to be one of those\n  ptr.next= {|(n | lst.head | ptr)|};\n  assert ptr.next.val == n.val;\n  ptr.next.next= ??;\n  //might seem trivial but all I know is the last node of the list has to end in null.\n  assert ptr.next.next == null;\n  return lst;\n}\n\nList insertAt(List lst, Node n, int pos) {\n  if(pos == ??){\n    n.next = lst.head;\n    lst.head = n;\n    return lst;\n  }\n  Node ptr=lst.head;\n  int i=??;\n  //using a generator, I don't want to figure out the condition for updating ptr.\n  while(i < (pos -1) && ptr != ??){\n    ptr={|(ptr.next|ptr|lst.head)|};\n    i++;\n  }\n  // it's VERY difficult to understand how I link pointers. I'll just regex generator them and let sketch figure out\n  n.next={|(ptr.next|ptr|lst.head)|};\n  assert n.next == ptr.next;\n  ptr.next={|(ptr.next|ptr|lst.head| n)|};\n  assert ptr.next == n;\n  return lst;\n}\n\n\n\nList populate(List l) {\n  // this function adds a few nodes to an empty list.  This is used\n  // for providing input-output examples.\n  // returns: 5 -> 60\n  Node n2 = new Node(next = null, val = 60);\n  Node n1 = new Node(next = n2, val = 5);\n  l.head = n1;\n  return l;\n}\n\n\nharness void testAppend(){\n  List l = new List();\n  l = populate(l);\n  \n  // assert for append\n  Node n1 = new Node(next = null, val = 40);\n  List l1 = append(l, n1);\n  assert l1.head.next.next.val == 40;\n}\n\n\nharness void testInsert(){\n  List l = new List();\n  l = populate(l);\n\n  Node n1 = new Node(next = null, val = 70);\n  // assert for insertAt\n  List l2 = insertAt(l, n1, 1);\n  assert l2.head.next.val == 70;\n  //My test cases\n  l2 = insertAt(l, new Node(next = null, val = 39), 1);\n  assert l2.head.next.val == 39;\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n  //inserting after inserting at head\n  l2 = insertAt(l, new Node(next = null, val = 15), 0);\n  assert l2.head.val == 15;\n}\n\n//my append test harness\nharness void testapp(){\n  List l = new List(head = null);\n  l=append(l, new Node(next=null, val = 8));\n  assert l.head.val==8;\n  assert l.head.next==null;\n  l=append(l, new Node(next=null, val = 15));\n  assert l.head.next.val==15;\n  assert l.head.next.next==null; \n}"}}